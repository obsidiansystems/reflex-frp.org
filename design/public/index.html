<html lang="en">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1" data-ssr="" name="viewport">
  <title></title>
  <link rel="stylesheet" href="/css/tailwind.css">
</head>
<body>
  

asdfasd
  <div class="bg-white fixed z-10 w-screen top-0">
  <!-- Pre scroll -->
  <div class="max-w-screen-xl mx-auto px-4 pt-4 sm:px-6">
  <!-- Post scroll -->
  <!-- <div class="max-w-screen-xl mx-auto px-4 sm:px-6"> -->
    <!-- Pre scroll -->
    <nav class="relative h-20 flex justify-center items-center">
    <!-- Post scroll -->
    <!-- <nav class="relative h-16 flex justify-center items-center"> -->

      <a href="#" aria-label="Obsidian Systems Home" class="absolute left-0">
        <!-- Pre scroll -->
        <img class="h-4 w-auto md:h-5" src="/images/ObsidianSystemsLogo.svg" alt="OBSIDIAN.SYSTEMS">
        <!-- Post scroll -->
        <!-- <img class="h-3 w-auto md:h-4" src="images/ObsidianSystemsLogoInverted.svg" alt="OBSIDIAN.SYSTEMS"> -->
        <!-- Use the inverted logo for pages that start with a dark section, regular logo for screens that start with a light section -->
        <!-- <img class="h-3 w-auto md:h-4" src="images/ObsidianSystemsLogo.svg" alt="OBSIDIAN.SYSTEMS"> -->
      </a>
      
      <div class="hidden lg:block">
        <a href="#" class="p-2 rounded-md font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-800 transition ease-in-out duration-150 mr-8">
          <span class="icon-house-2 pr-2"></span>Home
        </a>
        <a href="#" class="p-2 rounded-md font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-800 transition ease-in-out duration-150">
          <span class="icon-block-2 pr-2"></span>Blockchain
        </a>
      </div>
      
      <!-- Pre scroll -->
      <button class="py-2 px-4 hidden lg:block absolute right-0 rounded border-2 border-gray-600 text-gray-600 hover:bg-gray-100 hover:text-gray-800 hover:border-gray-100 transition duration-150 ease-in-out">
        <span class="icon-chat pr-2"></span>Contact Us
      </button>
      <!-- Post scroll - only change is the py setting -->
      <!-- <button class="py-1 px-4 hidden lg:block absolute right-0 rounded border-2 border-gray-600 text-gray-600 hover:bg-gray-100 hover:text-gray-800 hover:border-gray-100 transition duration-150 ease-in-out">
        <span class="icon-chat pr-2"></span>Contact Us
      </button> -->
      
      <div class="absolute right-0 lg:hidden">
        <button type="button" class="flex items-center justify-center p-2 rounded-md text-gray-400 
          hover:text-gray-500 hover:bg-gray-100 
          focus:outline-none focus:bg-gray-100 focus:text-gray-500 
          transition duration-150 ease-in-out" 
          aria-label="Main menu" aria-haspopup="true">
          <svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
          </svg>
        </button>
      </div>
      
    </nav>
  </div>
</div>

  
  <div class="max-w-screen-xl mx-auto h-screen max-h-140 flex justify-center items-center flex-col">
    <a href="#" class="bg-purple-600 text-white p-6 rounded font-bold">Checkout the Get Started guide</a>
  </div>
  
  <h1 class="text-6xl">adfThe world changes, your apps should keep up.</h1>
  
    <h2>Reflex adapts to changes in your...</h2>
      <h3>Data</h3>
      <p>Reflex apps automatically react to changing data. This keeps every interaction current, accurately representing the relationship between your data and the real world.</p>
      <p>Reflex is the key to writing self-updating user interfaces.</p>

      <h3>Requirements</h3>
      <p>Reflex components are modular and reusable. If your requirements change, your app can quickly and easily be reworked. The modularity of Reflex lets you iterate quickly, without wasting code.</p>
      <p>Develop efficiently no matter how many times you pivot.</p>
      
      <h3>Platform</h3>
      <p>Reflex has been built to seamlessly support interfaces on desktop, mobile, web, and other platforms, all in Haskell. Regardless of your platform needs, Reflex lets you take your team and your code with you.</p>
      <p>One team, one code base, every platform.</p>
  
  <h1>The ecosystem built for evolution.</h1>
  
    <h2>Build fast without breaking things.</h2>
    <p>You don’t have to choose between building quickly or sustainably anymore. Reflex-FRP allows you to write production quality code from the get-go, with less technical debt.</p>
    
    <h2>Never lost in translation.</h2>
    <p>Reflex platform allows you to write entirely in Haskell, everywhere. Using one language does away with client / server protocol mismatches and separate engineering teams. Code becomes easier to write, with fewer kinds of bugs possible.</p>
    
    <h2>Jump the complexity wall.</h2>
    <p>As you add to your codebase, it inevitably becomes more complex, but it shouldn’t become harder to manage. No matter the size of your App, Reflex allows for individual pieces of code to be independently understandable.</p>
    
    <h2>Code for the only constant.</h2>
    <p>The only constants are time and change, what if your code could account for them? Functional reactive programming lets you write code that understands real world dynamics as naturally as you do, but isn’t any harder to write.</p>
    
    <h2>Batteries included.</h2>
    <p>Obelisk is the full-stack framework for building Reflex apps using the entire ecosystem. Designed to work ‘out of the box’, with best practices and starter templates included. This is the best option for developing and deploying serious real world applications, quickly.</p>
    

  
</body>
</html>